{"posts":[{"content":"\nMarkdown (MD) is the Rich Text Format of developers. With it we can put on a screen our ideas in a visual way without having to rely on other, more complicated, markup languages.\n\nI want to explore the process to insert markdown on React components and maybe go further each time.\n\n## Limitations of Markdown\n\nFirst of, let's get this out of the way: Markdown limits itself to text. That means it's only capable of handing headings (`h1`...`h6`), text, lists, links and images. Any other elements like `main`, `section`, `div` is out of MD's scope.\n\n## Simple rendering\n\nHere, I want to render text like this:\n\n```markdown\n# Hello World!\n\nThis is Markdown.\n```\n\nAnd have it render like this in HTML:\n\n```html\n<h1>Hello World!</h1>\n<p>This is Markdown.</p>\n```\n\nFortunately, there's already a few libraries that can do this: [react-markdown](https://github.com/rexxars/react-markdown), [react-markdown-renderer](https://github.com/InsidersByte/react-markdown-renderer) and [react-mde](https://github.com/andrerpena/react-mde).\n\nI will use react-markdown for this example.\n\n```jsx\nimport React from 'react'\nimport ReactMarkdown from 'react-markdown'\nimport './styles.css'\n\nconst input = `\n# Hello World!\n\nThis is Markdown.\n`\n\nexport default function App() {\n  return (\n    <div className='App'>\n      <ReactMarkdown source={input} />\n    </div>\n  )\n}\n```\n\nAnd sure enough, that works! Here is the result in [Codesandbox](https://codesandbox.io/s/react-markdown-simple-demo-9tbb8?file=/src/App.js).\n\nThat was easy. Now for something a little more complicated.\n\n## Rendering from a file\n\nIs it as easy as importing the MD file from our JSX file? It is as easy as importing the MD file from our JSX file!\n\nUsing react-markdown, for its simplicity, again.\n\n```jsx\nimport React from 'react'\nimport ReactMarkdown from 'react-markdown'\nimport HelloWorld from './hello-world.md'\nimport './styles.css'\n\nexport default function App() {\n  return (\n    <div className='App'>\n      <ReactMarkdown source={HelloWorld} />\n    </div>\n  )\n}\n```\n\nHere is the demo in [Codesandbox](https://codesandbox.io/s/react-markdown-from-file-demo-hni2h) again. It is even neater than the previous example. Now, something even more difficult.\n\n## Rendering multiple files\n\nFinally, I want to read multiple files at the same time and output their render as before.\n\nIn addition, I want to be able to output each file on it's own with a link.\n\nThis is done with a router. Fortunately, a [react-router](https://github.com/ReactTraining/react-router) exists! Even more so, I'm able to achieve what I wanted just reading at the first example in the page, which is excellent news. Also, Node has a module called `fs` that allows to read the file system, in this case our app environment. And it's as easy as a couple of lines. Assuming I have put my file on a a `/post` folder, I can execute this code.\n\n```jsx\nconst path = './src/posts/' // path for the MD files folder within our project\nconst fs = require('fs')\nconst fileList = fs.readdirSync('./src/posts') // creates an array of filenames\n```\n\nThen, I want to read the data contents, so I create a function for this.\n\n```jsx\nfunction getData(file) {\n  const data = fs.readFileSync(file, 'utf8')\n  return data ? data : null\n}\n```\n\nThis function takes a file and returns its content as a string. I have to declare encoding (`\"utf-8\"`) or else I get an array of number, which is the characters values in ASCII.\n\nNow I can create my app.\n\n```jsx\nexport default function App() {\n  return (\n    <div className='App'>\n      <Router>\n        <ul>\n          {fileList.map((post) => (\n            <li>\n              <Link to={`/${post}`}>{post}</Link>\n            </li>\n          ))}\n        </ul>\n\n        <Switch>\n          {fileList.map((post) => (\n            <Route path={`/${post}`}>\n              <ReactMarkdown source={getData(`${path}${post}`)} />\n            </Route>\n          ))}\n        </Switch>\n      </Router>\n    </div>\n  )\n}\n```\n\nI have surround all my code on the `<Router>` component for it to work and create separate `.map` functions for the link list and the actual routing. The `<Switch>` component takes care of rendering the text formatted from markdown\n\nThe result, in [Codesandbox](https://codesandbox.io/s/react-markdown-multiple-files-mdhry), is a bit hacky since it uses the file name as the link text. But I'm satisfied that I could get the result I was looking for with relative ease. All I'm left with is to explore how to read certain lines from a file to extract the title and fix the link text.","data":{"title":"Rendering Markdown on React","date":"2020-07-08T00:00:00.000Z","tags":"js react","slug":"2020-07-08-rendering-markdown-on-react","wordcount":765},"isEmpty":false,"excerpt":"","id":0},{"content":"\n## What are Git Submodules?\n\nTo be really short and concise, Submodules in Git are repositories inside other repositories.\n\n## Why would I need Submodules?\n\nSometimes a project might become too large and needs some of its parts to be developed independently but can't be separated. You could start tracking them as Submodules to ease their development.\n\nAnother use case might be when exploring a new language or framework and developing a test app (like a to-do app, a Hacker News clone or a pomodoro timer) you might want to keep track of all those apps to come back to them later, but also all in one place. Submodules are suited for this as well.\n\n## How to use Git Submodules?\n\nLet's create a new folder for our demo project, initialize Git and make our first commit with a newly created file.\n\n```bash\n$ mkdir submodules-demo\n$ cd submodules-demo\n$ git init\n$ echo \"# Git Submodules\" > README.md\n$ git add .\n$ git commit -m \"First commit\"\n$ git status\nOn branch main\nnothing to commit, working tree clean\n# push changes to a remote\n$ git remote add origin https://github.com/adcpe/submodule-demo.git\n$ git push -u origin main\n```\n\nThe repo is ready now.\n\nNow let's add a Submodule inside this repo. The Submodule can be an existing remote repo or a local new one. Let's take a look at both.\n\n### Adding an existing remote repo\n\nThe syntax for adding a existing remote repo is as follows.\n\n```bash\n$ git submodule add [url] [destination folder (optional)]\n```\n\nNow let's add a real repo and rename it inside the parent repo.\n\n```bash\n$ git submodule add https://github.com/adcpe/remote-sm-demo.git remote-demo\n```\n\nLet's commit this changes, using only one line to commit all current changes.\n\n```bash\n$ git commit -am \"Added a new remote submodule\"\n[main 3914b02] Added a new remote submodule\n 2 files changed, 4 insertions(+)\n create mode 100644 .gitmodules\n create mode 160000 remote-demo\n$ git status\nOn branch main\nYour branch is ahead of 'origin/main' by 1 commit.\n  (use \"git push\" to publish your local commits)\n\nnothing to commit, working tree clean\n```\n\nNow let's take a look a the method for adding a new local repo.\n\n### Adding a new local repo\n\nFor this method, we have to start by creating a new folder inside the parent, then initializing Git inside it and finally adding the new folder as a submodule\n\n```bash\n# create the folder and cd into it\n$ mkdir local-sm-demo\n$ cd local-sm-demo\n$ git init\n$ echo \"# local-sm-demo\" > README.md\n$ git commit -am \"First commit\"\n# go back to the parent folder\n$ cd ..\n# check the status of the parent repo\n$ git status\nOn branch main\nYour branch is ahead of 'origin/main' by 1 commit.\n  (use \"git push\" to publish your local commits)\n\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n\tmodified:   .gitmodules\n\tnew file:   local-sm-demo\n$ git commit -m \"Add the local submodule\"\n```\n\nWith this, now you have a fully functional local submodule.\n\nNote that this local submodule doesn't have a remote origin where it can be tracked independently. You should **always** do this but for this demo I will not.\n\n## .gitmodules\n\nYou might have noticed this file that was created when you added the first submodule. It's a simple and normally you don't need to do anything to it. Let's take a look at it.\n\n```\n[submodule \"remote-demo\"]\n\tpath = remote-demo\n\turl = https://github.com/andres-dc/remote-sm-demo.git\n[submodule \"local-sm-demo\"]\n\tpath = local-sm-demo\n\turl = ./local-sm-demo\n```\n\nWe can see that the details of the submodules are here. Here's an explanation of the first 3 lines:\n\n- `[submodule \"remote-demo\"]` states the given name of this submodule.\n- `path = remote-demo` refers to the folder name where our submodule is stored inside the parent directory.\n- `url = git@github.com:adcpe/remote-sm-demo.git` is the URL path of our remote repo.\n\nYou could add submodules by editing this file directly but I think the command line method is faster.\n\n## Cloning repos with submodules\n\nWhen you clone a repository with submodules, Git only clone the parent repo. Meaning, it creates the folders for the submodules but doesn't clone the submodules from their origin.\n\nLet's delete our parent directory and clone it from the remote.\n\n```bash\n$ cd ..\n$ rm -rf submodule-demo\n$ git clone https://github.com/andres-dc/submodule-demo.git\n$ cd submodule-demo\n$ ls -a\n.git  local-sm-demo  remote-demo  .gitmodules  README.md\n# now let's check inside the remote-demo folder\n$ ls -a remote-demo\n$\n```\n\nThis last command shows that the folder is empty. Let's fetch its contents.\n\nFirst, we must initialize the submodules.\n\n```bash\n$ git submodule init\nSubmodule 'local-sm-demo' (https://github.com/andres-dc/submodule-demo.git/local-sm-demo) registered for path 'local-sm-demo'\nSubmodule 'remote-demo' (https://github.com/andres-dc/remote-sm-demo.git) registered for path 'remote-demo'\n```\n\nThen, we can choose to fetch all submodules or select which one to fetch. Let's fetch the `remote-demo` submodule.\n\n```bash\n$ git submodule update remote-demo/\nCloning into '/home/adc/gh/submodule-demo/remote-demo'...\nSubmodule path 'remote-demo': checked out '65ab769a363247ea7a6395e4fdc5b2652e4a8fdd'\n$ ls -a remote-demo\n.git  README.md\n```\n\nNow we have our submodule up to date with the remote.\n\n## A few considerations\n\n- If we try to update the `local-sm-demo` directory we will get an error. This happens because the local repo had its commit history stored only locally. If we run the command it will try to pull from a non-existing history. It was deleted when the parent folder was deleted.\n- Every time you make a change inside a submodule, you commit changes as usual inside the folder. Then, you have to commit the changes in the parent directory so that you can later recall what was the latest state of the submodule.\n\n## Wrapping up\n\nSubmodules are useful and they can be used on large projects with many sub-projects or with projects that are similar and need to be tracked separately. I mostly use them for the latter because it allows me to keep track of test projects on new languages or frameworks.\n\nFor more information on Git Submodules, refer to [Git’s documentation](https://git-scm.com/book/en/v2/Git-Tools-Submodules).\n\nI hope this is as useful for you as it was for me writing it.","data":{"title":"Git Submodules","date":"2020-10-13T00:00:00.000Z","tags":"git","slug":"2020-10-13-git-submodules","wordcount":910},"isEmpty":false,"excerpt":"","id":1},{"content":"\nHere is a little guide to setting up IntelliSense and auto-completion on VSCode for Ruby quickly.\nRequirements\n\nMight seem a bit obvious, but you need the following in your computer:\n\n[VSCode](https://code.visualstudio.com/)\n\n[Ruby](https://www.ruby-lang.org/en/downloads/)\n\n## What will be installed?\n\n[Rubocop](https://rubocop.org/)\n\nFrom its page: The Ruby Linter/Formatter that Serves and Protects. It’s just that. A linter and formatter that takes rules from a configuration file ad applies them to Ruby files.\n\n[Airbnb Ruby style guide](https://github.com/airbnb/ruby)\n\nI use this one because its widespread and sane. I also use their [JavaScript style guide](https://github.com/airbnb/javascript).\n\n[Solargraph](https://solargraph.org/)\n\nSolargraph is a Ruby gem that provides intellisense features through Microsoft’s language server protocol. It can also lint and format code, but I find Rubocop better for that task.\n\n[Ruby extension for VSCode](https://marketplace.visualstudio.com/items?itemName=rebornix.Ruby)\n\n[Solargraph extension for VSCode]()\n\n## What is IntelliSense?\n\nIn a nutshell, IntelliSense provides autocomplete for your code (names for methods, classes, etc) and also inline documentation. For example, if you want to apply a Ruby method on an array, it will present you with all the methods for arrays as you type. It’s very useful and can speed up coding a lot.\n\n## The installation\n\n### Gem installation\n\nIn a terminal, enter this command:\n\n```bash\ngem install solargraph rubocop-airbnb\n```\n\nIt installs Solargraph and the Airbnb extension for Rubocop, which in turn installs Rubocop. It’s better to install Rubocop in this way only because VSCode reports of conflicting versions in the system otherwise. Extension installation\n\nThen, we install the VSCode extensions. You could look for `ruby.rebornix` and `castwide.solargraph` on the extension marketplace inside VSCode or copy/paste this commands on the command palette (usually Ctrl/Cmd + Shift + P or F1.)\n\n```bash\next install rebornix.Ruby\next install castwide.solargraph\n```\n\nNote: remember to remove the `>` that appears on the command palette.\n\n## Configurations\n\n### System configuration\n\nRubocop will take a global configuration file on your home directory. In Linux the path is `/home/<your-username>` and on Windows it should be `C:\\Users\\<your-username>`.\n\nThe filename is `.rubocop.yml` and it must contain these two lines.\n\n```\nrequire:\n- rubocop-airbnb\n```\n\n### VSCode settings\n\nIn VSCode, we need to edit settings.json. Copy and paste these lines and edit them with your values.\n\n```json\n\"ruby.interpreter.commandPath\": \"path/to/ruby\",\n\"ruby.useLanguageServer\": true,\n\"ruby.useBundler\": true,\n\n\"solargraph.commandPath\": \"path/to/solargraph\",\n\"solargraph.formatting\": true,\n\"solargraph.diagnostics\": true,\n\"[ruby]\": { \"editor.defaultFormatter\": \"castwide.solargraph\" },\n```\n\nTo find the correct paths to Ruby and Solargraph, enter these commands depending on your OS.\n\n#### Linux\n\n```bash\nwhich ruby which solargraph\n```\n\n##### Windows\n\n```bash\nwhere ruby where solargraph\n```\n\nAnd that’s it. With that, VSCode is now a great environment for writing Ruby code.","data":{"title":"Setting up Ruby for VSCode","date":"2021-02-04T00:00:00.000Z","tags":"ruby vscode","slug":"2021-02-04-ruby-vscode","wordcount":367},"isEmpty":false,"excerpt":"","id":2},{"content":"\nFor a long time I thought of a personal website as a chore. I'm not a much of a UI guy. I don't think I make compelling website designs. I don't know how to pick colors. I have a vague idea about fonts. I know which ones I like and they are mostly monospaced fonts. That's pretty much as far as far as I go.\n\nBut the reason I started making a website again was because I'm feeling it lately. There's this curiosity and desire to create that's coming back and needs to be satisfied.\n\nGuess I could say I was blocked or tired or both. I'm just it's over now because I need it.\n\nAnd, finally, I'm treating this website as a digital garden, which means I can work on it whenever I'm feeling in the mood.\n\nI want to write about my ongoing projects, but I want to finish at least one of them first.","data":{"title":"On Restarting","date":"2022-11-17T00:00:00.000Z","tags":"personal","slug":"2022-11-17-on-restarting","wordcount":153},"isEmpty":false,"excerpt":"","id":3},{"content":"\nNow that I'm more into blogging than any other time in my life, I wanted to start using this space more than ever.\n\nMy website is (or will be, because as of writing this post is not yet out) just a static site made with [11ty](https://www.11ty.dev/) and the blog will be a collection of all my posts, naturally. With this idea, I wanted to serve myself markdown files in the cheapest way possible.\n\nPreviously I had used [Sanity](https://www.sanity.io/). Sanity is alright. I get the appeal of it for teams that create content, but for me its just overkill. And the other side of it, I don't feel like I have my posts. Sanity could disappear any day and it would be a hassle to get my posts out of there. I wanted something that is future proof and that I have control of.\n\nImmediately I thought about writing an API is NodeJS or Ruby on Rails or maybve even Laravel. That's too much maintenance though. Sure, would make an interesting learning experience and probably another post, but I already had to build the site and other projects. Besides, I just wanted to write and the server costs were unappealing.\n\nSo after a while thinking about this problem I realized the solution was in front of me. Serving my posts from a Git repository was my original idea. The repo would be just markdown files with front matter. Very simple.\n\nWhat if I could just retrieve them with [axios](https://github.com/axios/axios) requests? Then I rememebered that you can view files from `raw.githubusercontent.com`. That's perfect.\n\n## The solution\n\nGreat! Now I just need a way to get the filenames on the posts folder. So I created a basic script with NodeJS using `fs` to write the filenames to a file and I'll push that along with the markdown files to Github. Then I would point my request to that file to get the other filenames and then I'd get the contents of my markdown files.\n\n## Extending my idea\n\nCan I get all my files with a single request instead of having to iterate over the file list? That's putting more processing on the initial file list creation.\n\nIn my reasearch I came upon [gray-matter](https://github.com/jonschlinkert/gray-matter), a handy npm package that takes markdown and spits out an object with the content and data from front matter.\n\nAwesome!\n\nSo, out of this my little script grew a bit more with gray-matter processing the `.md` files. I also couldn't push this data to a simple `.txt` files. The script would create a `.json` files instead and I also added some other metadata to the object. This is way more powerful than my simple file list.\n\nThe repository is living now in [Github](https://github.com/adcpe/blog-content) but I will create a mirror on Gitlab just in case.\n\n### Mine\n\nThis was a very fun problem to solve and I learned a bit with it. Now my content is truly mine, its portable and hopefully future proof.","data":{"title":"Using Github/Gitlab as my CDN/API","date":"2022-11-20T00:00:00.000Z","tags":"blogging experiment","slug":"2022-11-20-using-github-as-my-cdn-api","wordcount":480},"isEmpty":false,"excerpt":"","id":4}]}